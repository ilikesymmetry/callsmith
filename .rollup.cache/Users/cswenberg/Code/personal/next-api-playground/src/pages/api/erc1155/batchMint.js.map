{"version":3,"file":"batchMint.js","sourceRoot":"","sources":["batchMint.ts"],"names":[],"mappings":";AACA,kFAAkF;AAClF,sEAAsE;AACtE,0DAA0D;AAC1D,+CAA+C;AAC/C,qEAAqE;AACrE,0DAA0D;AAC1D,+CAA+C;AAC/C,4DAA4D;AAC5D,sDAAsD;AAEtD,8EAA8E;AAC9E,6DAA6D;AAC7D,8DAA8D;AAC9D,uBAAuB;AACvB,gCAAgC;AAChC,eAAe;AACf,mCAAmC;AACnC,kCAAkC;AAClC,iCAAiC;AACjC,WAAW;AACX,OAAO;AACP,2CAA2C;AAC3C,oBAAoB;AACpB,eAAe;AACf,uBAAuB;AACvB,aAAa;AACb,QAAQ;AACR,kEAAkE;AAClE,sBAAsB;AACtB,2DAA2D;AAC3D,yCAAyC;AACzC,uCAAuC;AACvC,UAAU;AACV,QAAQ;AAER,4DAA4D;AAC5D,yBAAyB;AACzB,mBAAmB;AACnB,yFAAyF;AACzF,SAAS;AACT,MAAM;AACN,2CAA2C;AAE3C,6DAA6D;AAC7D,aAAa;AACb,iCAAiC;AACjC,8DAA8D;AAC9D,sCAAsC;AACtC,OAAO;AAEP,0BAA0B;AAC1B,kFAAkF;AAClF,MAAM;AAEN,gEAAgE;AAChE,gCAAgC;AAChC,2BAA2B;AAC3B,qCAAqC;AACrC,4DAA4D;AAC5D,QAAQ;AACR,uBAAuB;AACvB,mBAAmB;AACnB,yFAAyF;AACzF,SAAS;AACT,MAAM;AAEN,UAAU;AACV,gDAAgD;AAChD,6BAA6B;AAC7B,gCAAgC;AAChC,kCAAkC;AAClC,kBAAkB;AAClB,mCAAmC;AACnC,kCAAkC;AAClC,iCAAiC;AACjC,aAAa;AACb,WAAW;AACX,SAAS;AACT,iEAAiE;AACjE,2BAA2B;AAC3B,kCAAkC;AAClC,mCAAmC;AACnC,+BAA+B;AAC/B,UAAU;AACV,uDAAuD;AAEvD,6BAA6B;AAC7B,uBAAuB;AACvB,yBAAyB;AACzB,qEAAqE;AACrE,UAAU;AACV,uBAAuB;AACvB,gCAAgC;AAChC,4EAA4E;AAC5E,MAAM;AACN,IAAI;AAEJ,MAAM,CAAC,OAAO,UAAgB,OAAO,CACnC,GAAmB,EACnB,GAAoB;;;YAEpB,IAAI,CAAC;gBACH,wCAAwC;YAC1C,CAAC;YAAC,OAAO,CAAM,EAAE,CAAC;gBAChB,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;gBAC3C,GAAG,CAAC,GAAG,EAAE,CAAC;gBACV,sBAAO;YACT,CAAC;YAED,IAAI,CAAC;gBACH,mCAAmC;gBACnC,sBAAO,GAAG,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,EAAE,CAAC,EAAC;YAC3E,CAAC;YAAC,OAAO,CAAM,EAAE,CAAC;gBAChB,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;gBACzB,sBAAO,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,EAAC;YACpE,CAAC;;;;CACF","sourcesContent":["import type { NextApiRequest, NextApiResponse } from \"next\";\n// import { getTransactionUrl, requireFields, requireMethods } from \"@/lib/utils\";\n// import { Address, encodeFunctionData, isAddressEqual } from \"viem\";\n// import grouposConfig from \"../../../../groupos.config\";\n// import { readContract } from \"viem/actions\";\n// import { getApiWalletClient, getClient } from \"@/lib/viem/client\";\n// import { PermissionsAbi } from \"@/lib/abi/Permissions\";\n// import { Operation } from \"@/lib/constants\";\n// import { ERC1155RailsAbi } from \"@/lib/abi/ERC1155Rails\";\n// import { MulticallAbi } from \"@/lib/abi/Multicall\";\n\n// async function batchMintTokens(req: NextApiRequest, res: NextApiResponse) {\n//   console.log(\"new request /erc1155/batchMint\", req.body);\n//   const { chainId, contractAddress, mints } = req.body as {\n//     chainId: number;\n//     contractAddress: Address;\n//     mints: {\n//       recipientAddress: Address;\n//       tokenId: string | number;\n//       amount: string | number;\n//     }[];\n//   };\n//   console.log(\"request body\", req.body);\n//   requireFields({\n//     chainId,\n//     contractAddress,\n//     mints,\n//   });\n//   mints.forEach(({ recipientAddress, tokenId, amount }, i) => {\n//     requireFields({\n//       [`mints.${i}.recipientAddress`]: recipientAddress,\n//       [`mints.${i}.tokenId`]: tokenId,\n//       [`mints.${i}.amount`]: amount,\n//     });\n//   });\n\n//   const walletClient = await getApiWalletClient(chainId);\n//   if (!walletClient) {\n//     throw Error(\n//       \"Could not construct API WalletClient. Must set API_PRIVATE_KEY in environment.\"\n//     );\n//   }\n//   console.log(\"connected walletClient\");\n\n//   const tokenContract = grouposConfig.tokenContracts.find(\n//     (v) =>\n//       v.chainId === chainId &&\n//       isAddressEqual(v.contractAddress, contractAddress) &&\n//       v.tokenStandard === \"ERC1155\"\n//   );\n\n//   if (!tokenContract) {\n//     return res.status(404).json({ message: \"Token contract does not exist.\" });\n//   }\n\n//   const apiCanMint = await readContract(getClient(chainId), {\n//     address: contractAddress,\n//     abi: PermissionsAbi,\n//     functionName: \"hasPermission\",\n//     args: [Operation.MINT, walletClient.account.address],\n//   });\n//   if (!apiCanMint) {\n//     throw Error(\n//       `Token missing MINT permission for API account: ${walletClient.account.address}`\n//     );\n//   }\n\n//   try {\n//     const multicallData = mints.map((mint) =>\n//       encodeFunctionData({\n//         abi: ERC1155RailsAbi,\n//         functionName: \"mintTo\",\n//         args: [\n//           mint.recipientAddress,\n//           BigInt(mint.tokenId),\n//           BigInt(mint.amount),\n//         ],\n//       })\n//     );\n//     const transactionHash = await walletClient.writeContract({\n//       abi: MulticallAbi,\n//       address: contractAddress,\n//       functionName: \"multicall\",\n//       args: [multicallData],\n//     });\n//     console.log(\"new transaction\", transactionHash);\n\n//     res.status(200).json({\n//       success: true,\n//       transactionHash,\n//       transactionUrl: getTransactionUrl(chainId, transactionHash),\n//     });\n//   } catch (e: any) {\n//     console.error(e.message);\n//     throw Error(\"Error encountered in minting. Please contact support.\");\n//   }\n// }\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  try {\n    // requireMethods([\"POST\"], req.method);\n  } catch (e: any) {\n    res.status(405).json({ error: e.message });\n    res.end();\n    return;\n  }\n\n  try {\n    // await batchMintTokens(req, res);\n    return res.json({ test: true, random: Math.floor(Math.random() * 100) });\n  } catch (e: any) {\n    console.error(e.message);\n    return res.status(500).json({ success: false, error: e.message });\n  }\n}\n"]}