{"version":3,"file":"mint.js","sourceRoot":"","sources":["mint.ts"],"names":[],"mappings":";AACA,kFAAkF;AAClF,oEAAoE;AACpE,0DAA0D;AAC1D,+CAA+C;AAC/C,qEAAqE;AACrE,wDAAwD;AACxD,0DAA0D;AAC1D,+CAA+C;AAE/C,SAAe,UAAU,CAAC,GAAmB,EAAE,GAAoB;;;;;;CAuElE;AAED,MAAM,CAAC,OAAO,UAAgB,OAAO,CACnC,GAAmB,EACnB,GAAoB;;;;;;oBAEpB,IAAI,CAAC;wBACH,wCAAwC;oBAC1C,CAAC;oBAAC,OAAO,CAAM,EAAE,CAAC;wBAChB,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;wBAC3C,GAAG,CAAC,GAAG,EAAE,CAAC;wBACV,sBAAO;oBACT,CAAC;;;;oBAGC,qBAAM,UAAU,CAAC,GAAG,EAAE,GAAG,CAAC,EAAA;;oBAA1B,SAA0B,CAAC;;;;oBAE3B,OAAO,CAAC,KAAK,CAAC,GAAC,CAAC,OAAO,CAAC,CAAC;oBACzB,sBAAO,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,GAAC,CAAC,OAAO,EAAE,CAAC,EAAC;;;;;CAErE","sourcesContent":["import type { NextApiRequest, NextApiResponse } from \"next\";\n// import { getTransactionUrl, requireFields, requireMethods } from \"@/lib/utils\";\n// import { Hex, erc20Abi, isAddressEqual, parseUnits } from \"viem\";\n// import grouposConfig from \"../../../../groupos.config\";\n// import { readContract } from \"viem/actions\";\n// import { getApiWalletClient, getClient } from \"@/lib/viem/client\";\n// import { ERC20RailsAbi } from \"@/lib/abi/ERC20Rails\";\n// import { PermissionsAbi } from \"@/lib/abi/Permissions\";\n// import { Operation } from \"@/lib/constants\";\n\nasync function mintTokens(req: NextApiRequest, res: NextApiResponse) {\n  // console.log(\"new request /erc20/mint\", req.body);\n  // const { chainId, contractAddress, recipientAddress, amount } = req.body as {\n  //   chainId: number;\n  //   contractAddress: Hex;\n  //   recipientAddress: Hex;\n  //   amount: number;\n  // };\n  // console.log(\"request body\", req.body);\n  // requireFields({ chainId, contractAddress, recipientAddress, amount });\n\n  // const walletClient = await getApiWalletClient(chainId);\n  // if (!walletClient) {\n  //   throw Error(\n  //     \"Could not construct API WalletClient. Must set API_PRIVATE_KEY in environment.\"\n  //   );\n  // }\n  // console.log(\"connected walletClient\");\n\n  // const tokenContract = grouposConfig.tokenContracts.find(\n  //   (v) =>\n  //     v.chainId === chainId &&\n  //     isAddressEqual(v.contractAddress, contractAddress) &&\n  //     v.tokenStandard === \"ERC20\"\n  // );\n\n  // if (!tokenContract) {\n  //   return res.status(404).json({ message: \"Token contract does not exist.\" });\n  // }\n\n  // const decimals = await readContract(getClient(chainId), {\n  //   address: contractAddress,\n  //   abi: erc20Abi,\n  //   functionName: \"decimals\",\n  // });\n\n  // if (decimals === undefined) {\n  //   throw Error(\"Token contract does not have decimals.\");\n  // }\n\n  // const apiCanMint = await readContract(getClient(chainId), {\n  //   address: contractAddress,\n  //   abi: PermissionsAbi,\n  //   functionName: \"hasPermission\",\n  //   args: [Operation.MINT, walletClient.account.address],\n  // });\n\n  // if (!apiCanMint) {\n  //   throw Error(\n  //     `Token missing MINT permission for API account: ${walletClient.account.address}`\n  //   );\n  // }\n\n  // try {\n  //   const transactionHash = await walletClient.writeContract({\n  //     abi: ERC20RailsAbi,\n  //     address: contractAddress,\n  //     functionName: \"mintTo\",\n  //     args: [recipientAddress, parseUnits(amount.toString(), decimals)],\n  //   });\n  //   console.log(\"new transaction\", transactionHash);\n\n  //   res.status(200).json({\n  //     success: true,\n  //     transactionHash,\n  //     transactionUrl: getTransactionUrl(chainId, transactionHash),\n  //   });\n  // } catch (e: any) {\n  //   console.error(e.message);\n  //   throw Error(\"Error encountered in minting. Please contact support.\");\n  // }\n}\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  try {\n    // requireMethods([\"POST\"], req.method);\n  } catch (e: any) {\n    res.status(405).json({ error: e.message });\n    res.end();\n    return;\n  }\n\n  try {\n    await mintTokens(req, res);\n  } catch (e: any) {\n    console.error(e.message);\n    return res.status(500).json({ success: false, error: e.message });\n  }\n}\n"]}