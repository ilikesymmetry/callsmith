{"version":3,"file":"metadata.js","sourceRoot":"","sources":["metadata.ts"],"names":[],"mappings":";AACA,WAAW;AACX,4BAA4B;AAC5B,sBAAsB;AACtB,kCAAkC;AAClC,qDAAqD;AACrD,mDAAmD;AACnD,+EAA+E;AAC/E,iFAAiF;AACjF,mFAAmF;AACnF,6CAA6C;AAC7C,4DAA4D;AAC5D,+DAA+D;AAC/D,+CAA+C;AAC/C,iDAAiD;AAEjD,wCAAwC;AACxC,yBAAyB;AACzB,0DAA0D;AAC1D,MAAM;AACN,iEAAiE;AACjE,uBAAuB;AACvB,gCAAgC;AAChC,uBAAuB;AACvB,OAAO;AACP,0DAA0D;AAC1D,6CAA6C;AAE7C,sDAAsD;AACtD,oBAAoB;AACpB,8CAA8C;AAC9C,kEAAkE;AAClE,OAAO;AAEP,0BAA0B;AAC1B,0EAA0E;AAC1E,MAAM;AAEN,SAAS;AACT,SAAS;AACT,oDAAoD;AACpD,kDAAkD;AAClD,QAAQ;AACR,QAAQ;AACR,2EAA2E;AAC3E,MAAM;AAEN,6EAA6E;AAC7E,qBAAqB;AACrB,gCAAgC;AAChC,4BAA4B;AAC5B,QAAQ;AAER,wEAAwE;AACxE,kCAAkC;AAClC,uEAAuE;AACvE,4EAA4E;AAC5E,4EAA4E;AAC5E,kBAAkB;AAClB,2DAA2D;AAC3D,4BAA4B;AAC5B,iBAAiB;AACjB,mBAAmB;AACnB,OAAO;AAEP,SAAS;AACT,kDAAkD;AAClD,mEAAmE;AACnE,QAAQ;AACR,6CAA6C;AAC7C,qCAAqC;AACrC,+CAA+C;AAC/C,kCAAkC;AAClC,UAAU;AACV,sCAAsC;AACtC,wDAAwD;AACxD,iDAAiD;AACjD,iBAAiB;AAEjB,cAAc;AACd,8BAA8B;AAC9B,+BAA+B;AAC/B,gCAAgC;AAChC,8BAA8B;AAC9B,iCAAiC;AACjC,6BAA6B;AAC7B,mCAAmC;AACnC,qBAAqB;AACrB,WAAW;AACX,kCAAkC;AAClC,6BAA6B;AAC7B,mCAAmC;AACnC,qBAAqB;AACrB,WAAW;AACX,mCAAmC;AACnC,6BAA6B;AAC7B,mCAAmC;AACnC,qBAAqB;AACrB,WAAW;AACX,UAAU;AAEV,0DAA0D;AAC1D,uBAAuB;AACvB,+BAA+B;AAC/B,8BAA8B;AAC9B,+BAA+B;AAC/B,gCAAgC;AAChC,UAAU;AAEV,2CAA2C;AAC3C,+EAA+E;AAC/E,QAAQ;AACR,MAAM;AAEN,oCAAoC;AACpC,YAAY;AACZ,IAAI;AAEJ,MAAM,CAAC,OAAO,UAAgB,OAAO,CACnC,GAAmB,EACnB,GAAoB;;;YAEpB,IAAI,CAAC;gBACH,uCAAuC;YACzC,CAAC;YAAC,OAAO,CAAM,EAAE,CAAC;gBAChB,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;gBAC3C,GAAG,CAAC,GAAG,EAAE,CAAC;gBACV,sBAAO;YACT,CAAC;YAED,IAAI,CAAC;gBACH,kCAAkC;YACpC,CAAC;YAAC,OAAO,CAAM,EAAE,CAAC;gBAChB,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;gBACzB,sBAAO,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,EAAC;YACpE,CAAC;;;;CACF","sourcesContent":["import type { NextApiRequest, NextApiResponse } from \"next\";\n// import {\n//   generateComputedTraits,\n//   getImageFromPath,\n// } from \"@/lib/erc721/metadata\";\n// import { computeTbaAddress } from \"@/lib/erc6551\";\n// import config from \"../../../../groupos.config\";\n// import { getErc20OwnersForTraits } from \"@/lib/api/getErc20OwnersForTraits\";\n// import { getErc721TokensForTraits } from \"@/lib/api/getErc721TokensForTraits\";\n// import { getErc1155OwnersForTraits } from \"@/lib/api/getErc1155OwnersForTraits\";\n// import { NftMetadata } from \"@/lib/types\";\n// import { Address, erc20Abi, isAddressEqual } from \"viem\";\n// import { requireFields, requireMethods } from \"@/lib/utils\";\n// import { readContract } from \"viem/actions\";\n// import { getClient } from \"@/lib/viem/client\";\n\n// export async function getNftMetadata(\n//   req: NextApiRequest,\n//   res: NextApiResponse<NftMetadata | { error: string }>\n// ) {\n//   const { chainId, contractAddress, tokenId } = req.query as {\n//     chainId: string;\n//     contractAddress: Address;\n//     tokenId: string;\n//   };\n//   requireFields({ chainId, contractAddress, tokenId });\n//   const parsedChainId = parseInt(chainId);\n\n//   const tokenContract = config.tokenContracts.find(\n//     (contract) =>\n//       contract.chainId === parsedChainId &&\n//       isAddressEqual(contract.contractAddress, contractAddress)\n//   );\n\n//   if (!tokenContract) {\n//     return res.status(404).json({ error: \"Token contract not found\" });\n//   }\n\n//   if (\n//     !(\n//       tokenContract.tokenStandard === \"ERC721\" ||\n//       tokenContract.tokenStandard === \"ERC1155\"\n//     )\n//   ) {\n//     return res.status(500).json({ error: \"Token contract is not NFT\" });\n//   }\n\n//   const tokenContractName = await readContract(getClient(parsedChainId), {\n//     abi: erc20Abi,\n//     address: contractAddress,\n//     functionName: \"name\",\n//   });\n\n//   const tokenMetadata = tokenContract.nftMetadata?.tokens?.[tokenId];\n//   let metadata: NftMetadata = {\n//     name: tokenMetadata?.name ?? `${tokenContractName} #${tokenId}`,\n//     description: tokenMetadata?.description ?? tokenContract.description,\n//     image: getImageFromPath(tokenMetadata?.image ?? tokenContract.image),\n//     attributes:\n//       tokenMetadata?.traits?.map(({ name, value }) => ({\n//         trait_type: name,\n//         value,\n//       })) ?? [],\n//   };\n\n//   if (\n//     tokenContract.tokenStandard === \"ERC721\" &&\n//     (tokenContract.nftMetadata?.computedTraits ?? []).length > 0\n//   ) {\n//     const tbaAddress = computeTbaAddress({\n//       tokenChainId: parsedChainId,\n//       tokenContractAddress: contractAddress,\n//       tokenId: BigInt(tokenId),\n//     });\n//     const sourceContractAddresses =\n//       tokenContract.nftMetadata!.computedTraits!.map(\n//         (trait) => trait.sourceContractAddress\n//       ) || [];\n\n//     const [\n//       erc20OwnersForTraits,\n//       erc721TokensForTraits,\n//       erc1155OwnersForTraits,\n//     ] = await Promise.all([\n//       getErc20OwnersForTraits(\n//         parseInt(chainId),\n//         sourceContractAddresses,\n//         tbaAddress\n//       ),\n//       getErc721TokensForTraits(\n//         parseInt(chainId),\n//         sourceContractAddresses,\n//         tbaAddress\n//       ),\n//       getErc1155OwnersForTraits(\n//         parseInt(chainId),\n//         sourceContractAddresses,\n//         tbaAddress\n//       ),\n//     ]);\n\n//     const computedAttributes = generateComputedTraits({\n//       tokenContract,\n//       token: { tbaAddress },\n//       erc20OwnersForTraits,\n//       erc721TokensForTraits,\n//       erc1155OwnersForTraits,\n//     });\n\n//     if (computedAttributes.length > 0) {\n//       metadata.attributes = [...metadata.attributes, ...computedAttributes];\n//     }\n//   }\n\n//   res.status(200).json(metadata);\n//   return;\n// }\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  try {\n    // requireMethods([\"GET\"], req.method);\n  } catch (e: any) {\n    res.status(405).json({ error: e.message });\n    res.end();\n    return;\n  }\n\n  try {\n    // await getNftMetadata(req, res);\n  } catch (e: any) {\n    console.error(e.message);\n    return res.status(500).json({ success: false, error: e.message });\n  }\n}\n"]}